#!/bin/sh
#
# chkconfig: 345 81 19
# description: Starts and stops Documentum Content Server
# processname: documentum-docbase
# author: Mark Faine <mark.faine@nasa.gov>
# $Id: documentum-docbase 24 2011-06-22 19:44:24Z mark.faine@gmail.com $

## Source Documentum configuration

## 2017-01-18 Gareth McMillan
## Coppied from Mark's work, updated to use DCTM7.3

#to be placed in /etc/init.d

if [ -e /etc/profile.d/documentum.sh ]; then
 . /etc/profile.d/documentum.sh
else
  echo "Check and configure documentum configuration script in /etc/profile.d"
  exit 1
fi

## Source LSB init functions
if [ -e /etc/init.d/functions ]; then
. /etc/init.d/functions
else
  echo "Missing LSB init functions script"
  exit 1
fi

## Specific to this process

SERVICE_NAME="Documentum Content Server"
PROCESS=<%=@repository_service%>
REPOSITORY=<%=@repository_name%>
PROCESS_CONFIG_FILE="${DOCUMENTUM}/dba/config/${REPOSITORY}/server.ini"

# Verify existence of repository configuration file
if [[ ! -e "${PROCESS_CONFIG_FILE}" ]]; then
 echo "server.ini for repository '${REPOSITORY}'is not accessible - please correct and try again"
 exit 1
fi
PORT="$(cat /etc/services | grep edms | awk  '{ print $2 }' | grep -Eio "[0-9]{4}" | tr  "\n" " ")"
PROCESS_START_CMD="${DOCUMENTUM}/dba/dm_start_fcms"
#PROCESS_START_CMD="${DM_HOME}/bin/documentum -docbase_name ${REPOSITORY} -security acl -init_file ${PROCESS_CONFIG_FILE}"

## Trace options
SQLTRACE=-osqltrace
AUTHTRACE=-otrace_authentication

## End Specific to this process

PROCESS_PID_FILE=${DOCUMENTUM}/dba/${PROCESS}.pid
PROCESS_LOCK_FILE=${DOCUMENTUM}/dba/${PROCESS}

# Logging
if [[ ! -z "${LOGDIR}" && "${LOGDIR}" != ""  &&  -e "${LOGDIR}" ]]; then
    PROCESS_LOGFILE="${LOGDIR}/${PROCESS}.$(hostname).t.$TIME.log"
else
  echo "Log directory ${LOGDIR} is inaccessible, please correct and try again"
  exit 1
fi

# Specific to this process
function start_process(){
  # Start dependent process
  status dmdocbroker > /dev/null 2>&1
  if [[ $? -gt 0 ]]; then
    /etc/init.d/dmdocbroker start
  fi
  # only shift if we have more than one argument
  # not all cases require the shift - somtimes it causes a problem:
  # 1: command not found error message
  if [[ ! -n "$1" ]]; then
    shift
  fi
  trace_args="$@"
  DAEMONIZE=/usr/local/sbin/daemonize
  echo -n "Starting Content Server ${REPOSITORY}"
  PROCESS_START_CMD="${PROCESS_START_CMD} ${trace_args}"
  if [ ! -z "$DMUSER" ]; then
    if [ "$EUID" = "0" ]; then
      $DAEMONIZE -u ${DMUSER} -c ${DM_HOME}/bin -e ${PROCESS_LOGFILE} -o ${PROCESS_LOGFILE} -p ${PROCESS_PID_FILE} -l ${PROCESS_LOCK_FILE} ${PROCESS_START_CMD}
    elif [ "$EUID" = $(id -u $DMUSER) ];  then
      $DAEMONIZE -c ${DM_HOME}/bin -e ${PROCESS_LOGFILE} -o ${PROCESS_LOGFILE} -p ${PROCESS_PID_FILE} -l ${PROCESS_LOCK_FILE} ${PROCESS_START_CMD}
    else
  	  echo "Service must be run as root, or $DMUSER"
  	  exit
    fi
  fi
  if [[ $? -eq 0 ]]; then
    success "${SERVICE_NAME}: ${REPOSITORY} startup"
  else
    failure "${SERVICE_NAME}: ${REPOSITORY} startup"
  fi
  echo
  sleep 15
}

function apishutdown(){
su - ${DMUSER} -c "${DM_HOME}/bin/iapi ${REPOSITORY} -U${DMUSER} -P -e <<EOF
shutdown,c,T,T
exit
EOF"
}

function stop_process(){
 # Call with attemptnumber as argument
  # attemptnumber will default to 1
  # child processes are given the chance to terminate gracefully but
  # on final attempt child processes will be force killed
  #
  attemptnum=$1
  if [[ ${attemptnum} = "" ]]; then
   attemptnum=1
  fi
  maxattempts=3
  ppid=$( su ${DMUSER} -c "${DM_HOME}/bin/get_pid ${REPOSITORY} ${DMUSER}" )

  # Only call if the first time this function has executed
  if [[ ${ppid} -ne "" ]]; then
    if [[ "${tried_shutdown}" == "false" ]]; then
      echo -n "Stopping Content Server ${REPOSITORY} (pid ${ppid}) on ports ${PORT} "
      apishutdown > /dev/null 2>&1
      tried_shutdown="true"
    fi

  # check for child processes - kill on final attempt
    sleep 30
    cpids=$( pgrep -P ${ppid} )
    if [[ "${cpids}" != "" && ${attemptnum} -le ${maxattempts} ]]; then
     echo -n .
     if [[ ${attemptnum} -eq ${maxattempts} ]]; then
       echo "Processes (pids ${ppid} ${cpids}) remain after multiple attempts to stop"
       echo "Killing remaining processes for  ${REPOSITORY}"
       pkill -9 -P "${ppid}"
     else
       let "attemptnum+=1"
       stop_process ${attemptnum}
     fi
   fi
   # Remove pid and lock files
   if [[ -e ${PROCESS_PID_FILE} ]]; then
     rm -f ${PROCESS_PID_FILE}
   fi
   if [[ -e ${PROCESS_LOCK_FILE} ]]; then
        rm -f ${PROCESS_LOCK_FILE}
   fi
  fi
  success "${PROCESS} ${REPOSITORY} shutdown"
  echo
}
# End Specific to this process


case "$1" in
  start)
        # If already running don't attempt to start
        if [[ -e ${PROCESS_PID_FILE} && -e ${PROCESS_LOCK_FILE} ]]; then
          status "${PROCESS}" > /dev/null 2>&1
          if [[ $? -eq 0 ]]; then
             exit 0
          fi
        fi
	# Call process specific start function
	start_process "$@"
        ;;
  stop)
        status "${PROCESS}" > /dev/null 2>&1
        if [ $? -eq 3 ]; then
           exit 0
        fi
        # control recursion of stop_process
        tried_shutdown="false"
        # Call process specific function
	stop_process
        ;;
  restart)
        $0 stop
	    $0 start
        ;;
  start_sqltrace)
        $0 start $SQLTRACE
		;;
  start_authtrace)
        $0 start $AUTHTRACE
		;;
  start_fulltrace)
        $0 start $SQLTRACE $AUTHTRACE
		;;
  status)
	    status "${PROCESS}"
	    ;;
  *)
        echo "Usage: service ${PROCESS} {start|stop|restart|start_sqltrace|start_authtrace|start_fulltrace|status}"
        exit 1
esac
